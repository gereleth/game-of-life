{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import { onMount } from 'svelte';\n    import { game } from './game_logic.js'\n\n    const backgroundColor = 'black'\n    const foregroundColor = '#2bb'\n    const gridColor = '#555'\n    let canvasWidth, canvasHeight;\n\n    let cellSize = 25;\n    let centerX = 0.5;\n    let centerY = 0.5;\n\n    let canvas, context;\n    let stepTime = 0;\n    let drawTime = 0;\n\n    let timerId;\n    let speed = 10;\n    let running = false;\n    let drawing = false;\n    let drawAlive = true;\n    let helpVisible = false;\n\n    let mouseX, mouseY;\n    let numCells=0;\n\n    function clearCanvas() {\n        context.clearRect(0,0,canvas.width, canvas.height)\n        context.fillStyle = backgroundColor\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawGridLines() {\n        if (cellSize>=10) {\n            const dx = cellSize*(centerX-Math.floor(centerX))\n            const centerLeft = canvas.width/2 - dx\n            const firstLeft = centerLeft - cellSize*Math.floor(centerLeft/cellSize)\n\n            const dy = cellSize*(centerY-Math.floor(centerY))\n            const centerTop = canvas.height/2 - dy\n            const firstTop = centerTop - cellSize*Math.floor(centerTop/cellSize)\n\n            context.strokeStyle = gridColor\n            context.beginPath();\n            let h;\n            for (var i=0; i<Math.ceil(canvas.height/cellSize); i++) {\n                h = Math.floor(firstTop+i*cellSize)+0.5;\n                context.moveTo(0.0, h);\n                context.lineTo(canvas.width, h);\n            }\n            for (var i=0; i<Math.ceil(canvas.width/cellSize); i++) {\n                h = Math.floor(firstLeft+i*cellSize)+0.5;\n                context.moveTo(h, 0.0);\n                context.lineTo(h, canvas.height);\n            }\n            context.stroke();\n            context.closePath();\n        }\n    }\n\n    function drawCells() {\n        let cell\n        for (let cellString of game.livingSet) {\n            cell = game.parse(cellString);\n            fillCell(cell, foregroundColor)\n        }\n    }\n\n    function drawGrid(cellSize) {\n        clearCanvas()\n        drawGridLines()\n        drawCells()\n    }\n\n    function zoom(event) {\n        event.preventDefault();\n        const zoomOut = event.deltaY > 0\n        // change cellSize 5% for every deltaY unit\n        let zoomDelta = Math.floor(Math.abs(event.deltaY)*5*cellSize/100)\n        // If that change is too small then use 1\n        zoomDelta = Math.max(zoomDelta, 1);\n        const newCellSize = Math.min(Math.max(1, cellSize + (zoomOut ? -1 : 1)*zoomDelta), 200);\n        let [pixelsX, pixelsY] = getPixelsFromMouseEvent(event)\n        pixelsX -= canvas.width/2\n        pixelsY -= canvas.height/2\n        const relX = centerX + pixelsX/cellSize;\n        const relY = centerY + pixelsY/cellSize;\n        centerX = (relX - pixelsX/newCellSize);\n        centerY = (relY - pixelsY/newCellSize);\n        centerX = Math.round(2*centerX)/2;\n        centerY = Math.round(2*centerY)/2;\n        cellSize = newCellSize;\n    }\n\n    let directions = new Set();\n    function onKeyDown(event) {\n        if ((event.keyCode===87)|(event.keyCode===38)) { // w or ArrowUp\n            directions.add('up');\n        } else if ((event.keyCode===83)|(event.keyCode===40)) { //s or ArrowDown\n            directions.add('down');\n        } else if ((event.keyCode===65)|(event.keyCode===37)) { // a or ArrowLeft\n            directions.add('left');\n        } else if ((event.keyCode===68)|(event.keyCode===39)) { //d or ArrowRight\n            directions.add('right');\n        }\n        const delta = 20/cellSize\n        const deltaX = (directions.has('right') ? delta : 0) - (directions.has('left') ? delta : 0)\n        const deltaY = (directions.has('down') ? delta : 0) - (directions.has('up') ? delta : 0)\n        if ((deltaX!==0)|(deltaY!==0)) {\n            if (drawing) {\n                const cells = getCellsBetween(mouseX, mouseY, mouseX+deltaX, mouseY+deltaY)\n                if (cells.length > 0) {\n                    if (drawAlive) {\n                        updateGrid(cells, [])\n                    } else {\n                        updateGrid([], cells)\n                    }\n                }\n                mouseX += deltaX\n                mouseY += deltaY\n            }\n            centerX += deltaX\n            centerY += deltaY\n            drawGrid();\n        }\n    }\n\n    function onKeyUp(event) {\n        if ((event.keyCode===87)|(event.keyCode===38)) { // w or ArrowUp\n            directions.delete('up');\n        } else if ((event.keyCode===83)|(event.keyCode===40)) { //s or ArrowDown\n            directions.delete('down');\n        } else if ((event.keyCode===65)|(event.keyCode===37)) { // a or ArrowLeft\n            directions.delete('left');\n        } else if ((event.keyCode===68)|(event.keyCode===39)) { //d or ArrowRight\n            directions.delete('right');\n        }\n    }\n\n    function coordToCell(cx, cy) {\n        return {\n            r: Math.floor(cy),\n            c: Math.floor(cx),\n        }\n    }\n    function getPixelsFromMouseEvent(event) {\n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        return [x, y]\n    }\n\n\n    function getCoordFromMouseEvent(event) {\n        const [x, y] = getPixelsFromMouseEvent(event)\n        return pixelsToCoord(x, y)\n    }\n\n    function pixelsToCoord(x, y) {\n        const coord = [\n            centerX + (x-1-canvas.width/2 )/cellSize,\n            centerY + (y-1-canvas.height/2)/cellSize,\n        ]\n        return coord\n    }\n\n    function pixelsToCell(x, y) {\n        const [cx, cy] = pixelsToCoord(x, y);\n        return coordToCell(cx, cy)\n    }\n\n    function cellToTopLeftPixels(cell) {\n        const pixels = {\n            x: Math.floor(canvas.width/2  + 1 + (cell.c - centerX)*cellSize),\n            y: Math.floor(canvas.height/2 + 1 + (cell.r - centerY)*cellSize),\n        }\n        return pixels\n    }\n\n    function integersBetween(z1, z2) {\n        const result = []\n        if (z2 > z1) {\n            for (let i=Math.ceil(z1); i<z2; i++) {\n                result.push(i)\n            }\n        } else {\n            for (let i=Math.floor(z1); i>z2; i--) {\n                result.push(i)\n            }\n        }\n        return result\n    }\n\n    function getCellsBetween(x1, y1, x2, y2) {\n        const lx = x2 - x1;\n        const ly = y2 - y1;\n        let innerX, innerY\n        let cells = []\n        // look for points where the line intersects cell boundaries\n        // not guarding against duplicate cells here\n        for (innerX of integersBetween(x1, x2)) {\n            innerY = y1 + ly * (innerX - x1) / lx\n            cells.push(coordToCell(innerX-1, innerY))\n            cells.push(coordToCell(innerX, innerY))\n        }\n        for (innerY of integersBetween(y1, y2)) {\n            innerX = x1 + lx * (innerY - y1) / ly\n            cells.push(coordToCell(innerX, innerY-1))\n            cells.push(coordToCell(innerX, innerY))\n        }\n        return cells\n    }\n\n\n    function handleMouseDown(event) {\n        const [cx, cy] = getCoordFromMouseEvent(event)\n        const cell = coordToCell(cx, cy)\n        drawAlive = !(game.isCellAlive(cell))\n        if (drawAlive) {\n            updateGrid([cell], [])\n        } else {\n            updateGrid([], [cell])\n        }\n        drawing = true\n        mouseX = cx\n        mouseY = cy\n    }\n\n    function handleMouseMove(event) {\n        if (drawing) {\n            const [cx, cy] = getCoordFromMouseEvent(event)\n            const cells = getCellsBetween(mouseX, mouseY, cx, cy)\n            if (cells.length > 0) {\n                if (drawAlive) {\n                    updateGrid(cells, [])\n                } else {\n                    updateGrid([], cells)\n                }\n            }\n            mouseX = cx\n            mouseY = cy\n        }\n    }\n\n    function handleMouseUp(event) {\n        const [cx, cy] = getCoordFromMouseEvent(event)\n        const cell = coordToCell(cx, cy)\n        if (drawAlive) {\n            updateGrid([cell], [])\n        } else {\n            updateGrid([], [cell])\n        }\n        drawing = false\n    }\n\n    // touch handling\n    let ongoingTouches = []\n    let lastTouchTime = 0\n\n    function handleTouchStart(event) {\n        event.preventDefault();\n        for (let touch of event.changedTouches) {\n            ongoingTouches.push({\n                id: touch.identifier,\n                clientX: touch.clientX,\n                clientY: touch.clientY,\n            });\n        }\n        lastTouchTime = performance.now();\n        if (ongoingTouches.length==1) {\n            const [cx, cy] = getCoordFromMouseEvent(ongoingTouches[0])\n            const cell = coordToCell(cx, cy)\n            drawAlive = !(game.isCellAlive(cell))\n            drawing = true;\n        } else if (ongoingTouches.length>1) {\n            drawing = false;\n        }\n    }\n    function handleTouchMove(event) {\n        event.preventDefault();\n        let time = performance.now();\n        if ((time - lastTouchTime >= 50)\n                &&(ongoingTouches.length == 1)\n                &&(drawing)) {\n            // one finger moves - draw\n            const newTouch = event.changedTouches[0]\n            const [cx, cy] = getCoordFromMouseEvent(ongoingTouches[0])\n            const [newcx, newcy] = getCoordFromMouseEvent(newTouch)\n            const cells = getCellsBetween(newcx, newcy, cx, cy)\n            if (cells.length > 0) {\n                if (drawAlive) {\n                    updateGrid(cells, [])\n                } else {\n                    updateGrid([], cells)\n                }\n            }\n            ongoingTouches = [{\n                id: newTouch.identifier,\n                clientX: newTouch.clientX,\n                clientY: newTouch.clientY,\n            }];\n            lastTouchTime = time;\n        } else if ((time - lastTouchTime >= 200)\n                    &&(ongoingTouches.length==2)) {\n            // two fingers move - pan or zoom\n            const ids = ongoingTouches.map(item => item.id);\n            let newTouches = [...ongoingTouches]\n            let index\n            for (let touch of event.changedTouches) {\n                index = ids.indexOf(touch.identifier)\n                newTouches[index] = {\n                    id: touch.identifier,\n                    clientX: touch.clientX,\n                    clientY: touch.clientY,\n                }\n            }\n            // how much did distance in pixels change between fingers\n            // scale cell size that much\n            const oldDistance = Math.sqrt(\n                (ongoingTouches[0].clientX-ongoingTouches[1].clientX)**2\n                +(ongoingTouches[0].clientY-ongoingTouches[1].clientY)**2)\n            const newDistance = Math.sqrt(\n                (newTouches[0].clientX-newTouches[1].clientX)**2\n                +(newTouches[0].clientY-newTouches[1].clientY)**2)\n            const newCellSize = Math.max(1, Math.round(newDistance*cellSize/oldDistance))\n            // how much did fingers move from their previous position?\n            // move the screen in that average direction\n            const [cx0, cy0] = getCoordFromMouseEvent(ongoingTouches[0])\n            const [cx1, cy1] = getCoordFromMouseEvent(ongoingTouches[1])\n            cellSize = newCellSize\n            const [newcx0, newcy0] = getCoordFromMouseEvent(newTouches[0])\n            const [newcx1, newcy1] = getCoordFromMouseEvent(newTouches[1])\n            const deltaX = 0.5*(newcx0-cx0+newcx1-cx1)\n            const deltaY = 0.5*(newcy0-cy0+newcy1-cy1)\n            centerX = centerX-deltaX;\n            centerY = centerY-deltaY;\n            drawGrid()\n            ongoingTouches = newTouches\n            }\n    }\n\n    function handleTouchEnd(event) {\n        event.preventDefault();\n        if (drawing && (ongoingTouches.length===1)) {\n            const [cx, cy] = getCoordFromMouseEvent(event.changedTouches[0])\n            const cell = coordToCell(cx, cy)\n            if (drawAlive) {\n                updateGrid([cell], [])\n            } else {\n                updateGrid([], [cell])\n            }\n            drawing = false;\n        }\n        for (let touch of event.changedTouches) {\n            ongoingTouches = ongoingTouches.filter(item => item.id!==touch.identifier)\n        }\n        lastTouchTime = performance.now();\n    }\n\n    function fillCell(cell, color) {\n        context.fillStyle = color;\n        const pixels = cellToTopLeftPixels(cell)\n        context.fillRect(\n            pixels.x, pixels.y,\n            cellSize-(cellSize<=2 ? 0.0 : 1.0),\n            cellSize-(cellSize<=2 ? 0.0 : 1.0)\n        );\n    }\n\n    function updateGrid(births, deaths) {\n        let t0 = performance.now()\n        if ((births.length==0)&(deaths.length===0)) {stop()}\n        game.update(births, deaths);\n        for (let cell of births) {\n            fillCell(cell, foregroundColor)\n        }\n        for (let cell of deaths) {\n            fillCell(cell, backgroundColor)\n        }\n        drawTime=performance.now()-t0\n        numCells = game.livingSet.size;\n    }\n\n    function step() {\n        let t0 = performance.now()\n        let births, deaths\n        [births, deaths] = game.step();\n        stepTime = performance.now()-t0;\n        updateGrid(births, deaths);\n    }\n\n    function clear() {\n        game.clear()\n        drawGrid();\n        numCells = game.livingSet.size;\n    }\n\n    function run() {\n        if (!running) {\n            timerId = setInterval(() => step(), 1000/speed);\n            running = true;\n        }\n    }\n\n    function stop() {\n        if (running) {\n            clearInterval(timerId)\n            running = false;\n        }\n    }\n\n    function set_speed(speed) {\n        if (running) {\n            stop()\n            run()\n        }\n    }\n\n    async function onResize() {\n        canvas.width=10\n        canvas.height=10\n        const rect = canvas.parentNode.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n        drawGrid(cellSize)\n    }\n        onMount(async () => {\n            context = canvas.getContext(\"2d\");\n            // There's some resizing going on in the beginning\n            // If I call onResize here it works like half the time\n            // The other half - size of canvas stays 150*300\n            // Or window width*10\n            // This timeout is an ugly hack (but works?...)\n            setTimeout(onResize,42);\n            // onResize()\n        });\n\n    $: if (canvas) {\n        drawGrid(cellSize);\n    }\n    $: set_speed(speed);\n</script>\n\n<svelte:window on:keydown={onKeyDown} on:keyup={onKeyUp} on:resize={onResize}/>\n<div class=\"controls\">\n    <div class=\"row\">\n        <button\n            type=\"button\"\n            name=\"help\"\n            title=\"Show help\"\n            on:click={()=>helpVisible=!helpVisible}\n            >?</button>\n        <button on:click={clear} title=\"Clear all cells from grid\">Clear</button>\n        <button on:click={step} disabled={running}>\n            Step\n        </button>\n        <button on:click={running ? stop : run}>\n            {running ? 'Stop' : 'Run'}\n        </button>\n    </div>\n    <div class=\"row\">\n        <label for=\"speed\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"5\" max=\"500\" step=\"1\" bind:value={speed} />\n    </div>\n    <div class=\"row\">\n        <div>\n            cells:<br/>{numCells}\n        </div>\n        <div>\n            step:<br/>{stepTime} ms\n        </div>\n        <div>\n            draw:<br/>{drawTime} ms\n        </div>\n    </div>\n    {#if helpVisible}\n    <ul>\n        <li><a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">Conway's Game of Life</a>.</li>\n        <li>Click or touch and drag to draw shapes</li>\n        <li>Press Run to see them evolve</li>\n        <li>Use W,A,S,D or arrows to move around, mouse wheel to zoom</li>\n        <li>Or touch with two fingers to pan and zoom</li>\n    </ul>\n    {/if}\n</div>\n<canvas id=\"gridCanvas\"\n                class=\"gridCanvas\"\n                bind:this={canvas}\n                on:mouseup={handleMouseUp}\n                on:mousedown={handleMouseDown}\n                on:mousemove={handleMouseMove}\n                on:wheel={zoom}\n                on:touchstart={handleTouchStart}\n                on:touchmove={handleTouchMove}\n                on:touchend={handleTouchEnd}\n                on:touchcancel={handleTouchEnd}\n                ></canvas>\n\n<style>\n    div.controls {\n        display:flex;\n        flex-direction:column;\n        position:absolute;\n        top: 5px;\n        left: 5px;\n        max-width:250px;\n        padding: 0 5px;\n        background:rgba(180,180,180,0.8);\n        border-radius: 5px;\n    }\n   canvas {\n      display: block;\n   }\n    button {\n        width: 3.5em;\n        border-radius:5px;\n        background:#bbb;\n    }\n    div.row {\n        display:flex;\n        flex-direction:row;\n        justify-content: space-between;\n        align-items:center;\n        padding: 5px 0;\n    }\n    div.row>div {\n        flex: 1 1 0px;\n    }\n</style>\n"
  ],
  "names": [],
  "mappings": "AAofI,GAAG,SAAS,4BAAC,CAAC,AACV,QAAQ,IAAI,CACZ,eAAe,MAAM,CACrB,SAAS,QAAQ,CACjB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,CACT,UAAU,KAAK,CACf,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,WAAW,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAChC,aAAa,CAAE,GAAG,AACtB,CAAC,AACF,MAAM,4BAAC,CAAC,AACL,OAAO,CAAE,KAAK,AACjB,CAAC,AACA,MAAM,4BAAC,CAAC,AACJ,KAAK,CAAE,KAAK,CACZ,cAAc,GAAG,CACjB,WAAW,IAAI,AACnB,CAAC,AACD,GAAG,IAAI,4BAAC,CAAC,AACL,QAAQ,IAAI,CACZ,eAAe,GAAG,CAClB,eAAe,CAAE,aAAa,CAC9B,YAAY,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,AAClB,CAAC,AACD,GAAG,kBAAI,CAAC,GAAG,cAAC,CAAC,AACT,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,AACjB,CAAC"
}